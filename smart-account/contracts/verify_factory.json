{
  "language": "Solidity",
  "sources": {
    "src/SimpleQuasarAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"./SimpleQuasarAccount.sol\";\nimport \"./interfaces/IDilithiumPublicKey.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@tetrationlab/dilithium/contract/Dilithium.sol\";\nimport \"@tetrationlab/dilithium/contract/Packing.sol\";\n\ncontract SimpleQuasarAccountFactory {\n    Dilithium immutable dilithium;\n    Packing immutable packing;\n\n    error AccountAlreadyCreated(address account, address publicKey, bytes32 publicKeyHash);\n\n    mapping(address => bool) public created;\n    mapping(bytes32 => address[2]) public registry;\n\n    event AccountCreated(address indexed account, address indexed publicKey, bytes32 indexed publicKeyHash);\n\n    constructor(Dilithium _dilithium, Packing _packing) {\n        dilithium = _dilithium;\n        packing = _packing;\n    }\n\n    function createAccount(IDilithiumPublicKey publicKey) external returns (address) {\n        bytes32 pkHash = keccak256(abi.encode(publicKey.expandedPublicKey()));\n\n        if (registry[pkHash][0] != address(0)) {\n            revert AccountAlreadyCreated(registry[pkHash][0], registry[pkHash][1], pkHash);\n        }\n\n        address account = Create2.deploy(\n            0, pkHash, abi.encodePacked(type(SimpleQuasarAccount).creationCode, abi.encode(dilithium, packing))\n        );\n        SimpleQuasarAccount(payable(account)).initialize(publicKey);\n        created[account] = true;\n        registry[pkHash] = [account, address(publicKey)];\n\n        emit AccountCreated(account, address(publicKey), pkHash);\n\n        return account;\n    }\n}\n"
    },
    "src/SimpleQuasarAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"./interfaces/IDilithiumPublicKey.sol\";\nimport \"@tetrationlab/dilithium/contract/Dilithium.sol\";\nimport \"@tetrationlab/dilithium/contract/Packing.sol\";\n\ncontract SimpleQuasarAccount {\n    Dilithium immutable dilithium;\n    Packing immutable packing;\n\n    IDilithiumPublicKey public publicKey;\n\n    constructor(Dilithium _dilithium, Packing _packing) {\n        dilithium = _dilithium;\n        packing = _packing;\n    }\n\n    function initialize(IDilithiumPublicKey _publicKey) external {\n        if (address(publicKey) != address(0)) {\n            revert(\"Already initialized\");\n        }\n        publicKey = _publicKey;\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    function verify(bytes calldata signature, bytes32 message) public view returns (bool) {\n        Dilithium.ExpandedPublicKey memory epk = publicKey.expandedPublicKey();\n        Dilithium.Signature memory sig = packing.unpack_sig(signature);\n        return dilithium.verifyExpanded(sig, epk, bytes.concat(message));\n    }\n\n    function execute(address dest, uint256 value, bytes calldata func, bytes calldata signature) external {\n        require(verify(signature, keccak256(abi.encode(dest, value, func))), \"Invalid signature\");\n        _call(dest, value, func);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/interfaces/IDilithiumPublicKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"@tetrationlab/dilithium/contract/Dilithium.sol\";\n\ninterface IDilithiumPublicKey {\n    function expandedPublicKey() external view returns (Dilithium.ExpandedPublicKey memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/Dilithium.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"./Packing.sol\";\nimport \"./Poly.sol\";\nimport \"./PolyVec.sol\";\n\ncontract Dilithium {\n    Polynomial immutable _poly;\n    PolynomialVector immutable _polyvec;\n    Packing immutable _packing;\n\n    constructor(Polynomial __poly, PolynomialVector __polyvec, Packing __packing) {\n        _poly = __poly;\n        _polyvec = __polyvec;\n        _packing = __packing;\n    }\n\n    struct PublicKey {\n        uint256 rho;\n        PolynomialVector.PolyVecK t1;\n    }\n\n    struct ExpandedPublicKey {\n        bytes32 packed;\n        PolynomialVector.PolyVecL[K] mat;\n        PolynomialVector.PolyVecK t1;\n    }\n\n    struct Signature {\n        bytes32 c;\n        PolynomialVector.PolyVecL z;\n        PolynomialVector.PolyVecK h;\n    }\n\n    function expand(PublicKey memory pk) public view returns (ExpandedPublicKey memory epk) {\n        epk.packed = keccak256(_packing.pack(pk));\n        epk.t1 = _polyvec.clone_k(pk.t1);\n        epk.t1 = _polyvec.shiftl(epk.t1);\n        epk.t1 = _polyvec.ntt_k(epk.t1);\n        epk.mat = _polyvec.matrix_expand(pk.rho);\n    }\n\n    function verifyExpanded(Signature memory sig, ExpandedPublicKey memory pk, bytes memory m)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 mul = keccak256(bytes.concat(pk.packed, m));\n        bytes32 mur = keccak256(bytes.concat(mul));\n\n        if (_polyvec.chknorm(sig.z, int32(int256(GAMMA1 - BETA)))) {\n            return false;\n        }\n        Polynomial.Poly memory cp = _poly.challenge(sig.c);\n        sig.z = _polyvec.ntt_l(sig.z);\n        PolynomialVector.PolyVecK memory w1 = _polyvec.matrix_mpointwise(pk.mat, sig.z);\n        cp = _poly.ntt(cp);\n        pk.t1 = _polyvec.poly_mpointwise(cp, pk.t1);\n        w1 = _polyvec.sub(w1, pk.t1);\n        w1 = _polyvec.reduce(w1);\n        w1 = _polyvec.invntt_k(w1);\n\n        w1 = _polyvec.caddq(w1);\n        w1 = _polyvec.use_hint(w1, sig.h);\n        bytes memory buf = _polyvec.pack_w1(w1);\n\n        bytes32 c2 = keccak256(bytes.concat(mul, mur, buf));\n\n        return c2 == sig.c;\n    }\n\n    function verify(Signature memory sig, PublicKey memory pk, bytes memory m) public view returns (bool) {\n        ExpandedPublicKey memory epk = expand(pk);\n        return verifyExpanded(sig, epk, m);\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/Packing.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"./Dilithium.sol\";\nimport \"./Poly.sol\";\n\ncontract Packing {\n    Polynomial immutable _poly;\n\n    constructor(Polynomial __poly) {\n        _poly = __poly;\n    }\n\n    function pack(Dilithium.PublicKey memory pk) public view returns (bytes memory) {\n        unchecked {\n            bytes memory buf;\n            buf = bytes.concat(buf, bytes32(pk.rho));\n            for (uint256 i = 0; i < K; i++) {\n                buf = bytes.concat(buf, _poly.pack_t1(pk.t1.polys[i]));\n            }\n            return buf;\n        }\n    }\n\n    function unpack_pk(bytes memory _pk) public view returns (Dilithium.PublicKey memory pk) {\n        unchecked {\n            bytes memory _rho = new bytes(32);\n            for (uint256 i = 0; i < 32; i++) {\n                _rho[i] = _pk[i];\n            }\n            pk.rho = uint256(bytes32(_rho));\n            for (uint256 i = 0; i < K; i++) {\n                bytes memory buf = new bytes(POLYT1_PACKEDBYTES);\n                for (uint256 j = 0; j < POLYT1_PACKEDBYTES; j++) {\n                    buf[j] = _pk[32 + i * POLYT1_PACKEDBYTES + j];\n                }\n                pk.t1.polys[i] = _poly.unpack_t1(buf);\n            }\n        }\n    }\n\n    function unpack_sig(bytes memory _sig) public view returns (Dilithium.Signature memory sig) {\n        unchecked {\n            bytes memory _c = new bytes(32);\n            for (uint256 i = 0; i < 32; ++i) {\n                _c[i] = _sig[i];\n            }\n            sig.c = bytes32(_c);\n\n            uint256 index = 32;\n\n            for (uint256 i = 0; i < L; ++i) {\n                bytes memory buf = new bytes(POLYZ_PACKEDBYTES);\n                for (uint256 j = 0; j < POLYZ_PACKEDBYTES; j++) {\n                    buf[j] = _sig[index + j];\n                }\n                sig.z.polys[i] = _poly.unpack_z(buf);\n                index += POLYZ_PACKEDBYTES;\n            }\n\n            index = 32 + L * POLYZ_PACKEDBYTES;\n\n            uint8 k = 0;\n            for (uint256 i = 0; i < K; ++i) {\n                uint8 sigidxoi = uint8(_sig[index + OMEGA + i]);\n\n                if (sigidxoi < k || sigidxoi > OMEGA_U8) {\n                    revert(\"invalid signature, omega\");\n                }\n\n                for (uint256 j = k; j < sigidxoi; ++j) {\n                    if (j > k && _sig[index + j] <= _sig[index + j - 1]) {\n                        revert(\"invalid signature, not ordered\");\n                    }\n\n                    sig.h.polys[i].coeffs[uint8(_sig[index + j])] = 1;\n                }\n\n                k = sigidxoi;\n            }\n\n            for (uint8 j = k; j < OMEGA_U8; ++j) {\n                if (_sig[index + j] > 0) {\n                    revert(\"invalid signature, extra indices not zero\");\n                }\n            }\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "lib/dilithium-solidity/src/Constants.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nuint256 constant N = 256;\nuint256 constant N_256 = 32; // N / 8\nuint256 constant D = 13;\nuint32 constant D_U32 = 13;\n\nuint256 constant CRHBYTES = 64;\nuint256 constant SEEDBYTES = 32;\nuint256 constant PUBLIC_KEY_BYTES = SEEDBYTES + K * POLYT1_PACKEDBYTES;\nuint256 constant SIG_BYTES = SEEDBYTES + L * POLYZ_PACKEDBYTES + POLYVECH_PACKEDBYTES;\n\n// Dilithium mode-2\nuint256 constant OMEGA = 80;\nuint8 constant OMEGA_U8 = 80;\nuint256 constant K = 4;\nuint256 constant L = 4;\nuint256 constant TAU = 39;\nuint256 constant GAMMA1 = 1 << 17;\nuint256 constant GAMMA2 = 95232; // ( Q - 1 ) / 88\nint32 constant GAMMA1_I32 = 1 << 17;\nint32 constant GAMMA2_I32 = 95232;\nuint256 constant BETA = 78;\nuint256 constant POLYW1_PACKEDBYTES = 192;\nuint256 constant POLYT1_PACKEDBYTES = 320;\nuint256 constant POLYVECH_PACKEDBYTES = OMEGA + K;\nuint256 constant POLYZ_PACKEDBYTES = 576;\n\nuint256 constant SHAKE128_RATE = 168;\nuint256 constant SHAKE256_RATE = 136;\nuint256 constant STREAM128_BLOCKBYTES = SHAKE128_RATE;\nuint256 constant STREAM256_BLOCKBYTES = SHAKE256_RATE;\n\nint64 constant Q = 8380417;\nuint32 constant Q_U32 = 8380417;\nint32 constant Q_I32 = 8380417;\nint32 constant QINV = 58728449;\nint64 constant F = 41978;\n"
    },
    "lib/dilithium-solidity/src/contract/Poly.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"../Reduce.sol\";\nimport \"./Symmetric.sol\";\nimport \"../Sampler.sol\";\nimport {use_hint as use_hint_internal} from \"../Rounding.sol\";\nimport \"./Ntt.sol\";\n\ncontract Polynomial {\n    Ntt immutable _ntt;\n    Stream immutable _stream;\n\n    constructor(Ntt __ntt, Stream __stream) {\n        _ntt = __ntt;\n        _stream = __stream;\n    }\n\n    struct Poly {\n        int32[N] coeffs;\n    }\n\n    function clone(Poly memory a) public pure returns (Poly memory b) {\n        unchecked {\n            for (uint256 i = 0; i < N; ++i) {\n                b.coeffs[i] = a.coeffs[i];\n            }\n            return b;\n        }\n    }\n\n    function reduce(Poly memory a) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < N; ++i) {\n                a.coeffs[i] = reduce32(a.coeffs[i]);\n            }\n            return a;\n        }\n    }\n\n    function caddq(Poly memory a) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < N; ++i) {\n                a.coeffs[i] = caddq32(a.coeffs[i]);\n            }\n            return a;\n        }\n    }\n\n    function add(Poly memory a, Poly memory b) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < 256; i++) {\n                a.coeffs[i] = a.coeffs[i] + b.coeffs[i];\n            }\n            return a;\n        }\n    }\n\n    function sub(Poly memory a, Poly memory b) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < 256; i++) {\n                a.coeffs[i] = a.coeffs[i] - b.coeffs[i];\n            }\n            return a;\n        }\n    }\n\n    function shiftl(Poly memory a) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < N; i++) {\n                a.coeffs[i] = a.coeffs[i] << D_U32;\n            }\n            return a;\n        }\n    }\n\n    function ntt(Poly memory a) public view returns (Poly memory) {\n        a.coeffs = _ntt.ntt(a.coeffs);\n        return a;\n    }\n\n    uint256 constant POLY_UNIFORM_NBLOCKS = (768 + STREAM128_BLOCKBYTES - 1) / STREAM128_BLOCKBYTES;\n\n    function uniform(Poly memory a, uint256 seed, uint16 nonce) public view returns (Poly memory) {\n        unchecked {\n            uint256 buflen = POLY_UNIFORM_NBLOCKS * STREAM128_BLOCKBYTES;\n\n            Stream.State memory state = _stream.init(seed, nonce);\n            bytes memory buf;\n            (state, buf) = _stream.s128_squeeze_nblocks(state, POLY_UNIFORM_NBLOCKS);\n\n            uint256 ctr;\n            uint256 off;\n\n            {\n                int32[] memory _coef = new int32[](N);\n                for (uint256 i = 0; i < N; i++) {\n                    _coef[i] = a.coeffs[i];\n                }\n                (_coef, ctr) = rej_uniform(_coef, N, buf, buflen);\n                for (uint256 i = 0; i < N; i++) {\n                    a.coeffs[i] = _coef[i];\n                }\n            }\n\n            while (ctr < N) {\n                off = buflen % 3;\n                for (uint256 i = 0; i < off; i++) {\n                    buf[i] = buf[buflen - off + i];\n                }\n                buflen = off + STREAM128_BLOCKBYTES;\n                {\n                    bytes memory tmpbuf;\n                    (state, tmpbuf) = _stream.s128_squeeze_block(state);\n                    // buf[off..] = tmpbuf\n                    for (uint256 i = 0; i < STREAM128_BLOCKBYTES; i++) {\n                        buf[off + i] = tmpbuf[i];\n                    }\n                }\n                {\n                    int32[] memory _coef = new int32[](N - ctr);\n                    for (uint256 i = 0; i < (N - ctr); i++) {\n                        _coef[i] = a.coeffs[i + ctr];\n                    }\n                    (_coef, ctr) = rej_uniform(_coef, N - ctr, buf, buflen);\n                    for (uint256 i = 0; i < (N - ctr); i++) {\n                        a.coeffs[i + ctr] = _coef[i];\n                    }\n                }\n            }\n\n            return a;\n        }\n    }\n\n    function challenge(bytes32 seed) public view returns (Poly memory a) {\n        unchecked {\n            uint64 signs = 0;\n\n            Stream.State memory state = _stream.empty();\n            state = _stream.absorb(state, bytes.concat(seed));\n\n            bytes memory buf;\n            (state, buf) = _stream.s256_squeeze_block(state);\n\n            for (uint64 i = 0; i < 8; ++i) {\n                signs |= uint64(uint8(buf[i])) << (8 * i);\n            }\n\n            uint256 pos = 8;\n            uint256 b;\n\n            for (uint256 i = N - TAU; i < N; ++i) {\n                while (true) {\n                    if (pos >= SHAKE256_RATE) {\n                        (state, buf) = _stream.s256_squeeze_block(state);\n                        pos = 0;\n                    }\n                    b = uint256(uint8(buf[pos]));\n                    pos += 1;\n                    if (b <= i) {\n                        break;\n                    }\n                }\n\n                a.coeffs[i] = a.coeffs[b];\n                a.coeffs[b] = 1 - 2 * int32(int64(signs & 1));\n                signs >>= 1;\n            }\n        }\n    }\n\n    function mpointwise(Poly memory a, Poly memory b) public pure returns (Poly memory c) {\n        unchecked {\n            {\n                int64 tr = int64(a.coeffs[0]) * int64(b.coeffs[0]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[0] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[1]) * int64(b.coeffs[1]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[1] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[2]) * int64(b.coeffs[2]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[2] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[3]) * int64(b.coeffs[3]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[3] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[4]) * int64(b.coeffs[4]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[4] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[5]) * int64(b.coeffs[5]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[5] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[6]) * int64(b.coeffs[6]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[6] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[7]) * int64(b.coeffs[7]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[7] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[8]) * int64(b.coeffs[8]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[8] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[9]) * int64(b.coeffs[9]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[9] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[10]) * int64(b.coeffs[10]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[10] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[11]) * int64(b.coeffs[11]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[11] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[12]) * int64(b.coeffs[12]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[12] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[13]) * int64(b.coeffs[13]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[13] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[14]) * int64(b.coeffs[14]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[14] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[15]) * int64(b.coeffs[15]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[15] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[16]) * int64(b.coeffs[16]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[16] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[17]) * int64(b.coeffs[17]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[17] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[18]) * int64(b.coeffs[18]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[18] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[19]) * int64(b.coeffs[19]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[19] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[20]) * int64(b.coeffs[20]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[20] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[21]) * int64(b.coeffs[21]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[21] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[22]) * int64(b.coeffs[22]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[22] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[23]) * int64(b.coeffs[23]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[23] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[24]) * int64(b.coeffs[24]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[24] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[25]) * int64(b.coeffs[25]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[25] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[26]) * int64(b.coeffs[26]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[26] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[27]) * int64(b.coeffs[27]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[27] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[28]) * int64(b.coeffs[28]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[28] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[29]) * int64(b.coeffs[29]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[29] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[30]) * int64(b.coeffs[30]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[30] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[31]) * int64(b.coeffs[31]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[31] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[32]) * int64(b.coeffs[32]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[32] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[33]) * int64(b.coeffs[33]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[33] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[34]) * int64(b.coeffs[34]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[34] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[35]) * int64(b.coeffs[35]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[35] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[36]) * int64(b.coeffs[36]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[36] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[37]) * int64(b.coeffs[37]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[37] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[38]) * int64(b.coeffs[38]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[38] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[39]) * int64(b.coeffs[39]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[39] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[40]) * int64(b.coeffs[40]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[40] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[41]) * int64(b.coeffs[41]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[41] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[42]) * int64(b.coeffs[42]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[42] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[43]) * int64(b.coeffs[43]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[43] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[44]) * int64(b.coeffs[44]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[44] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[45]) * int64(b.coeffs[45]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[45] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[46]) * int64(b.coeffs[46]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[46] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[47]) * int64(b.coeffs[47]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[47] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[48]) * int64(b.coeffs[48]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[48] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[49]) * int64(b.coeffs[49]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[49] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[50]) * int64(b.coeffs[50]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[50] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[51]) * int64(b.coeffs[51]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[51] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[52]) * int64(b.coeffs[52]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[52] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[53]) * int64(b.coeffs[53]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[53] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[54]) * int64(b.coeffs[54]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[54] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[55]) * int64(b.coeffs[55]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[55] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[56]) * int64(b.coeffs[56]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[56] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[57]) * int64(b.coeffs[57]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[57] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[58]) * int64(b.coeffs[58]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[58] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[59]) * int64(b.coeffs[59]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[59] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[60]) * int64(b.coeffs[60]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[60] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[61]) * int64(b.coeffs[61]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[61] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[62]) * int64(b.coeffs[62]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[62] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[63]) * int64(b.coeffs[63]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[63] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[64]) * int64(b.coeffs[64]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[64] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[65]) * int64(b.coeffs[65]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[65] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[66]) * int64(b.coeffs[66]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[66] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[67]) * int64(b.coeffs[67]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[67] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[68]) * int64(b.coeffs[68]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[68] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[69]) * int64(b.coeffs[69]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[69] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[70]) * int64(b.coeffs[70]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[70] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[71]) * int64(b.coeffs[71]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[71] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[72]) * int64(b.coeffs[72]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[72] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[73]) * int64(b.coeffs[73]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[73] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[74]) * int64(b.coeffs[74]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[74] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[75]) * int64(b.coeffs[75]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[75] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[76]) * int64(b.coeffs[76]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[76] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[77]) * int64(b.coeffs[77]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[77] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[78]) * int64(b.coeffs[78]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[78] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[79]) * int64(b.coeffs[79]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[79] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[80]) * int64(b.coeffs[80]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[80] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[81]) * int64(b.coeffs[81]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[81] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[82]) * int64(b.coeffs[82]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[82] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[83]) * int64(b.coeffs[83]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[83] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[84]) * int64(b.coeffs[84]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[84] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[85]) * int64(b.coeffs[85]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[85] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[86]) * int64(b.coeffs[86]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[86] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[87]) * int64(b.coeffs[87]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[87] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[88]) * int64(b.coeffs[88]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[88] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[89]) * int64(b.coeffs[89]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[89] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[90]) * int64(b.coeffs[90]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[90] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[91]) * int64(b.coeffs[91]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[91] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[92]) * int64(b.coeffs[92]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[92] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[93]) * int64(b.coeffs[93]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[93] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[94]) * int64(b.coeffs[94]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[94] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[95]) * int64(b.coeffs[95]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[95] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[96]) * int64(b.coeffs[96]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[96] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[97]) * int64(b.coeffs[97]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[97] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[98]) * int64(b.coeffs[98]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[98] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[99]) * int64(b.coeffs[99]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[99] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[100]) * int64(b.coeffs[100]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[100] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[101]) * int64(b.coeffs[101]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[101] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[102]) * int64(b.coeffs[102]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[102] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[103]) * int64(b.coeffs[103]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[103] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[104]) * int64(b.coeffs[104]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[104] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[105]) * int64(b.coeffs[105]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[105] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[106]) * int64(b.coeffs[106]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[106] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[107]) * int64(b.coeffs[107]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[107] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[108]) * int64(b.coeffs[108]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[108] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[109]) * int64(b.coeffs[109]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[109] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[110]) * int64(b.coeffs[110]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[110] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[111]) * int64(b.coeffs[111]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[111] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[112]) * int64(b.coeffs[112]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[112] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[113]) * int64(b.coeffs[113]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[113] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[114]) * int64(b.coeffs[114]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[114] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[115]) * int64(b.coeffs[115]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[115] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[116]) * int64(b.coeffs[116]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[116] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[117]) * int64(b.coeffs[117]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[117] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[118]) * int64(b.coeffs[118]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[118] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[119]) * int64(b.coeffs[119]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[119] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[120]) * int64(b.coeffs[120]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[120] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[121]) * int64(b.coeffs[121]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[121] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[122]) * int64(b.coeffs[122]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[122] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[123]) * int64(b.coeffs[123]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[123] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[124]) * int64(b.coeffs[124]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[124] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[125]) * int64(b.coeffs[125]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[125] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[126]) * int64(b.coeffs[126]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[126] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[127]) * int64(b.coeffs[127]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[127] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[128]) * int64(b.coeffs[128]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[128] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[129]) * int64(b.coeffs[129]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[129] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[130]) * int64(b.coeffs[130]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[130] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[131]) * int64(b.coeffs[131]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[131] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[132]) * int64(b.coeffs[132]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[132] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[133]) * int64(b.coeffs[133]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[133] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[134]) * int64(b.coeffs[134]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[134] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[135]) * int64(b.coeffs[135]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[135] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[136]) * int64(b.coeffs[136]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[136] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[137]) * int64(b.coeffs[137]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[137] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[138]) * int64(b.coeffs[138]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[138] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[139]) * int64(b.coeffs[139]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[139] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[140]) * int64(b.coeffs[140]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[140] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[141]) * int64(b.coeffs[141]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[141] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[142]) * int64(b.coeffs[142]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[142] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[143]) * int64(b.coeffs[143]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[143] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[144]) * int64(b.coeffs[144]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[144] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[145]) * int64(b.coeffs[145]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[145] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[146]) * int64(b.coeffs[146]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[146] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[147]) * int64(b.coeffs[147]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[147] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[148]) * int64(b.coeffs[148]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[148] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[149]) * int64(b.coeffs[149]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[149] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[150]) * int64(b.coeffs[150]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[150] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[151]) * int64(b.coeffs[151]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[151] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[152]) * int64(b.coeffs[152]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[152] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[153]) * int64(b.coeffs[153]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[153] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[154]) * int64(b.coeffs[154]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[154] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[155]) * int64(b.coeffs[155]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[155] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[156]) * int64(b.coeffs[156]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[156] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[157]) * int64(b.coeffs[157]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[157] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[158]) * int64(b.coeffs[158]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[158] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[159]) * int64(b.coeffs[159]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[159] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[160]) * int64(b.coeffs[160]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[160] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[161]) * int64(b.coeffs[161]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[161] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[162]) * int64(b.coeffs[162]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[162] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[163]) * int64(b.coeffs[163]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[163] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[164]) * int64(b.coeffs[164]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[164] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[165]) * int64(b.coeffs[165]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[165] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[166]) * int64(b.coeffs[166]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[166] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[167]) * int64(b.coeffs[167]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[167] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[168]) * int64(b.coeffs[168]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[168] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[169]) * int64(b.coeffs[169]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[169] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[170]) * int64(b.coeffs[170]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[170] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[171]) * int64(b.coeffs[171]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[171] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[172]) * int64(b.coeffs[172]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[172] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[173]) * int64(b.coeffs[173]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[173] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[174]) * int64(b.coeffs[174]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[174] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[175]) * int64(b.coeffs[175]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[175] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[176]) * int64(b.coeffs[176]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[176] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[177]) * int64(b.coeffs[177]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[177] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[178]) * int64(b.coeffs[178]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[178] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[179]) * int64(b.coeffs[179]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[179] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[180]) * int64(b.coeffs[180]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[180] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[181]) * int64(b.coeffs[181]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[181] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[182]) * int64(b.coeffs[182]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[182] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[183]) * int64(b.coeffs[183]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[183] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[184]) * int64(b.coeffs[184]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[184] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[185]) * int64(b.coeffs[185]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[185] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[186]) * int64(b.coeffs[186]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[186] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[187]) * int64(b.coeffs[187]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[187] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[188]) * int64(b.coeffs[188]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[188] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[189]) * int64(b.coeffs[189]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[189] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[190]) * int64(b.coeffs[190]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[190] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[191]) * int64(b.coeffs[191]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[191] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[192]) * int64(b.coeffs[192]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[192] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[193]) * int64(b.coeffs[193]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[193] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[194]) * int64(b.coeffs[194]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[194] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[195]) * int64(b.coeffs[195]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[195] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[196]) * int64(b.coeffs[196]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[196] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[197]) * int64(b.coeffs[197]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[197] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[198]) * int64(b.coeffs[198]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[198] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[199]) * int64(b.coeffs[199]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[199] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[200]) * int64(b.coeffs[200]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[200] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[201]) * int64(b.coeffs[201]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[201] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[202]) * int64(b.coeffs[202]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[202] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[203]) * int64(b.coeffs[203]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[203] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[204]) * int64(b.coeffs[204]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[204] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[205]) * int64(b.coeffs[205]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[205] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[206]) * int64(b.coeffs[206]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[206] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[207]) * int64(b.coeffs[207]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[207] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[208]) * int64(b.coeffs[208]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[208] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[209]) * int64(b.coeffs[209]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[209] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[210]) * int64(b.coeffs[210]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[210] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[211]) * int64(b.coeffs[211]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[211] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[212]) * int64(b.coeffs[212]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[212] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[213]) * int64(b.coeffs[213]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[213] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[214]) * int64(b.coeffs[214]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[214] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[215]) * int64(b.coeffs[215]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[215] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[216]) * int64(b.coeffs[216]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[216] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[217]) * int64(b.coeffs[217]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[217] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[218]) * int64(b.coeffs[218]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[218] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[219]) * int64(b.coeffs[219]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[219] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[220]) * int64(b.coeffs[220]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[220] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[221]) * int64(b.coeffs[221]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[221] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[222]) * int64(b.coeffs[222]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[222] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[223]) * int64(b.coeffs[223]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[223] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[224]) * int64(b.coeffs[224]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[224] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[225]) * int64(b.coeffs[225]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[225] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[226]) * int64(b.coeffs[226]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[226] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[227]) * int64(b.coeffs[227]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[227] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[228]) * int64(b.coeffs[228]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[228] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[229]) * int64(b.coeffs[229]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[229] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[230]) * int64(b.coeffs[230]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[230] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[231]) * int64(b.coeffs[231]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[231] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[232]) * int64(b.coeffs[232]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[232] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[233]) * int64(b.coeffs[233]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[233] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[234]) * int64(b.coeffs[234]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[234] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[235]) * int64(b.coeffs[235]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[235] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[236]) * int64(b.coeffs[236]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[236] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[237]) * int64(b.coeffs[237]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[237] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[238]) * int64(b.coeffs[238]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[238] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[239]) * int64(b.coeffs[239]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[239] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[240]) * int64(b.coeffs[240]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[240] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[241]) * int64(b.coeffs[241]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[241] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[242]) * int64(b.coeffs[242]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[242] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[243]) * int64(b.coeffs[243]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[243] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[244]) * int64(b.coeffs[244]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[244] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[245]) * int64(b.coeffs[245]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[245] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[246]) * int64(b.coeffs[246]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[246] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[247]) * int64(b.coeffs[247]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[247] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[248]) * int64(b.coeffs[248]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[248] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[249]) * int64(b.coeffs[249]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[249] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[250]) * int64(b.coeffs[250]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[250] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[251]) * int64(b.coeffs[251]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[251] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[252]) * int64(b.coeffs[252]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[252] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[253]) * int64(b.coeffs[253]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[253] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[254]) * int64(b.coeffs[254]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[254] = int32((tr - tri * Q) >> 32);\n            }\n            {\n                int64 tr = int64(a.coeffs[255]) * int64(b.coeffs[255]);\n                int64 tri = int64(int32(tr) * QINV);\n                c.coeffs[255] = int32((tr - tri * Q) >> 32);\n            }\n        }\n\n        return c;\n    }\n\n    function use_hint(Poly memory a, Poly memory b) public pure returns (Poly memory) {\n        unchecked {\n            for (uint256 i = 0; i < N; ++i) {\n                a.coeffs[i] = use_hint_internal(a.coeffs[i], uint8(uint32(b.coeffs[i])));\n            }\n            return a;\n        }\n    }\n\n    function chknorm(Poly memory a, int32 b) public pure returns (bool) {\n        unchecked {\n            int32 t;\n            if (b > (Q_I32 - 1) / 8) {\n                return true;\n            }\n\n            for (uint256 i = 0; i < N; ++i) {\n                int32 ai = a.coeffs[i];\n                t = ai >> 31;\n                t = ai - (t & 2 * ai);\n                if (t >= b) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n\n    function pack_w1(Poly memory a) public pure returns (bytes memory) {\n        unchecked {\n            // if if GAMMA2 == (Q - 1) / 88\n            bytes memory r = new bytes(POLYW1_PACKEDBYTES);\n            for (uint256 i = 0; i < N / 4; ++i) {\n                r[3 * i + 0] = bytes1(uint8(uint32(a.coeffs[4 * i + 0])));\n                r[3 * i + 0] |= bytes1(uint8(uint32(a.coeffs[4 * i + 1] << 6)));\n\n                r[3 * i + 1] = bytes1(uint8(uint32(a.coeffs[4 * i + 1] >> 2)));\n                r[3 * i + 1] |= bytes1(uint8(uint32(a.coeffs[4 * i + 2] << 4)));\n\n                r[3 * i + 2] = bytes1(uint8(uint32(a.coeffs[4 * i + 2] >> 4)));\n                r[3 * i + 2] |= bytes1(uint8(uint32(a.coeffs[4 * i + 3] << 2)));\n            }\n            // else {\n            //     for i in 0..N / 2 {\n            //       r[i] = (a.coeffs[2 * i + 0] | (a.coeffs[2 * i + 1] << 4)) as u8;\n            //     }\n            //   }\n            return r;\n        }\n    }\n\n    function pack_t1(Poly memory a) public pure returns (bytes memory) {\n        unchecked {\n            bytes memory r = new bytes(POLYT1_PACKEDBYTES);\n            for (uint256 i = 0; i < N / 4; ++i) {\n                r[5 * i + 0] = bytes1(uint8(uint32(a.coeffs[4 * i + 0] >> 0)));\n                r[5 * i + 1] = bytes1(uint8(uint32((a.coeffs[4 * i + 0] >> 8) | (a.coeffs[4 * i + 1] << 2))));\n                r[5 * i + 2] = bytes1(uint8(uint32((a.coeffs[4 * i + 1] >> 6) | (a.coeffs[4 * i + 2] << 4))));\n                r[5 * i + 3] = bytes1(uint8(uint32((a.coeffs[4 * i + 2] >> 4) | (a.coeffs[4 * i + 3] << 6))));\n                r[5 * i + 4] = bytes1(uint8(uint32(a.coeffs[4 * i + 3] >> 2)));\n            }\n            return r;\n        }\n    }\n\n    function unpack_t1(bytes memory a) public pure returns (Poly memory r) {\n        unchecked {\n            for (uint256 i = 0; i < N / 4; ++i) {\n                r.coeffs[4 * i + 0] = int32(uint32(uint8(a[5 * i + 0])) | (uint32((uint8(a[5 * i + 1]))) << 8) & 0x3FF);\n                r.coeffs[4 * i + 1] =\n                    int32((uint32(uint8(a[5 * i + 1])) >> 2) | (uint32(uint8(a[5 * i + 2])) << 6) & 0x3FF);\n                r.coeffs[4 * i + 2] =\n                    int32((uint32(uint8(a[5 * i + 2])) >> 4) | (uint32(uint8(a[5 * i + 3])) << 4) & 0x3FF);\n                r.coeffs[4 * i + 3] =\n                    int32((uint32(uint8(a[5 * i + 3])) >> 6) | (uint32(uint8(a[5 * i + 4])) << 2) & 0x3FF);\n            }\n        }\n    }\n\n    function unpack_z(bytes memory a) public pure returns (Poly memory r) {\n        unchecked {\n            // if GAMMA1 == 1 << 17\n            for (uint256 i = 0; i < N / 4; ++i) {\n                r.coeffs[4 * i + 0] = int32(uint32(uint8(a[9 * i + 0])));\n                r.coeffs[4 * i + 0] |= int32(uint32(uint8(a[9 * i + 1]))) << 8;\n                r.coeffs[4 * i + 0] |= int32(uint32(uint8(a[9 * i + 2]))) << 16;\n                r.coeffs[4 * i + 0] &= 0x3FFFF;\n\n                r.coeffs[4 * i + 1] = int32(uint32(uint8(a[9 * i + 2]) >> 2));\n                r.coeffs[4 * i + 1] |= int32(uint32(uint8(a[9 * i + 3]))) << 6;\n                r.coeffs[4 * i + 1] |= int32(uint32(uint8(a[9 * i + 4]))) << 14;\n                r.coeffs[4 * i + 1] &= 0x3FFFF;\n\n                r.coeffs[4 * i + 2] = int32(uint32(uint8(a[9 * i + 4]) >> 4));\n                r.coeffs[4 * i + 2] |= int32(uint32(uint8(a[9 * i + 5]))) << 4;\n                r.coeffs[4 * i + 2] |= int32(uint32(uint8(a[9 * i + 6]))) << 12;\n                r.coeffs[4 * i + 2] &= 0x3FFFF;\n\n                r.coeffs[4 * i + 3] = int32(uint32(uint8(a[9 * i + 6]) >> 6));\n                r.coeffs[4 * i + 3] |= int32(uint32(uint8(a[9 * i + 7]))) << 2;\n                r.coeffs[4 * i + 3] |= int32(uint32(uint8(a[9 * i + 8]))) << 10;\n                r.coeffs[4 * i + 3] &= 0x3FFFF;\n\n                r.coeffs[4 * i + 0] = GAMMA1_I32 - r.coeffs[4 * i + 0];\n                r.coeffs[4 * i + 1] = GAMMA1_I32 - r.coeffs[4 * i + 1];\n                r.coeffs[4 * i + 2] = GAMMA1_I32 - r.coeffs[4 * i + 2];\n                r.coeffs[4 * i + 3] = GAMMA1_I32 - r.coeffs[4 * i + 3];\n            }\n        }\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/PolyVec.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"./Poly.sol\";\nimport \"./Ntt.sol\";\nimport \"./Invntt.sol\";\n\ncontract PolynomialVector {\n    struct PolyVecK {\n        Polynomial.Poly[K] polys;\n    }\n\n    struct PolyVecL {\n        Polynomial.Poly[L] polys;\n    }\n\n    Ntt immutable _ntt;\n    Invntt immutable _invntt;\n    Polynomial immutable _poly;\n\n    constructor(Ntt __ntt, Invntt __invntt, Polynomial __poly) {\n        _ntt = __ntt;\n        _invntt = __invntt;\n        _poly = __poly;\n    }\n\n    function clone_k(PolyVecK memory a) public pure returns (PolyVecK memory b) {\n        for (uint256 i = 0; i < K; ++i) {\n            for (uint256 j = 0; j < N; ++j) {\n                b.polys[i].coeffs[j] = a.polys[i].coeffs[j];\n            }\n        }\n    }\n\n    function clone_l(PolyVecL memory a) public pure returns (PolyVecL memory b) {\n        for (uint256 i = 0; i < K; ++i) {\n            for (uint256 j = 0; j < N; ++j) {\n                b.polys[i].coeffs[j] = a.polys[i].coeffs[j];\n            }\n        }\n    }\n\n    function ntt_l(PolyVecL memory a) public view returns (PolyVecL memory) {\n        // 0..L\n        a.polys[0].coeffs = _ntt.ntt(a.polys[0].coeffs);\n        a.polys[1].coeffs = _ntt.ntt(a.polys[1].coeffs);\n        a.polys[2].coeffs = _ntt.ntt(a.polys[2].coeffs);\n        a.polys[3].coeffs = _ntt.ntt(a.polys[3].coeffs);\n        return a;\n    }\n\n    function ntt_k(PolyVecK memory a) public view returns (PolyVecK memory) {\n        // 0..L\n        a.polys[0].coeffs = _ntt.ntt(a.polys[0].coeffs);\n        a.polys[1].coeffs = _ntt.ntt(a.polys[1].coeffs);\n        a.polys[2].coeffs = _ntt.ntt(a.polys[2].coeffs);\n        a.polys[3].coeffs = _ntt.ntt(a.polys[3].coeffs);\n        return a;\n    }\n\n    function invntt_k(PolyVecK memory a) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0].coeffs = _invntt.invntt(a.polys[0].coeffs);\n        a.polys[1].coeffs = _invntt.invntt(a.polys[1].coeffs);\n        a.polys[2].coeffs = _invntt.invntt(a.polys[2].coeffs);\n        a.polys[3].coeffs = _invntt.invntt(a.polys[3].coeffs);\n        return a;\n    }\n\n    function matrix_expand(uint256 rho) public view returns (PolyVecL[K] memory m) {\n        m[0].polys[0] = _poly.uniform(m[0].polys[0], rho, uint16((0 << 8) + 0));\n        m[0].polys[1] = _poly.uniform(m[0].polys[1], rho, uint16((0 << 8) + 1));\n        m[0].polys[2] = _poly.uniform(m[0].polys[2], rho, uint16((0 << 8) + 2));\n        m[0].polys[3] = _poly.uniform(m[0].polys[3], rho, uint16((0 << 8) + 3));\n\n        m[1].polys[0] = _poly.uniform(m[1].polys[0], rho, uint16((1 << 8) + 0));\n        m[1].polys[1] = _poly.uniform(m[1].polys[1], rho, uint16((1 << 8) + 1));\n        m[1].polys[2] = _poly.uniform(m[1].polys[2], rho, uint16((1 << 8) + 2));\n        m[1].polys[3] = _poly.uniform(m[1].polys[3], rho, uint16((1 << 8) + 3));\n\n        m[2].polys[0] = _poly.uniform(m[2].polys[0], rho, uint16((2 << 8) + 0));\n        m[2].polys[1] = _poly.uniform(m[2].polys[1], rho, uint16((2 << 8) + 1));\n        m[2].polys[2] = _poly.uniform(m[2].polys[2], rho, uint16((2 << 8) + 2));\n        m[2].polys[3] = _poly.uniform(m[2].polys[3], rho, uint16((2 << 8) + 3));\n\n        m[3].polys[0] = _poly.uniform(m[3].polys[0], rho, uint16((3 << 8) + 0));\n        m[3].polys[1] = _poly.uniform(m[3].polys[1], rho, uint16((3 << 8) + 1));\n        m[3].polys[2] = _poly.uniform(m[3].polys[2], rho, uint16((3 << 8) + 2));\n        m[3].polys[3] = _poly.uniform(m[3].polys[3], rho, uint16((3 << 8) + 3));\n    }\n\n    function mpointwise_acc(PolyVecL memory u, PolyVecL memory v) public view returns (Polynomial.Poly memory w) {\n        // 0\n        w = _poly.mpointwise(u.polys[0], v.polys[0]);\n        // 1..L\n        w = _poly.add(w, _poly.mpointwise(u.polys[1], v.polys[1]));\n        w = _poly.add(w, _poly.mpointwise(u.polys[2], v.polys[2]));\n        w = _poly.add(w, _poly.mpointwise(u.polys[3], v.polys[3]));\n        return w;\n    }\n\n    function matrix_mpointwise(PolyVecL[K] memory mat, PolyVecL memory v) public view returns (PolyVecK memory t) {\n        // 0..K\n        t.polys[0] = mpointwise_acc(mat[0], v);\n        t.polys[1] = mpointwise_acc(mat[1], v);\n        t.polys[2] = mpointwise_acc(mat[2], v);\n        t.polys[3] = mpointwise_acc(mat[3], v);\n        return t;\n    }\n\n    function poly_mpointwise(Polynomial.Poly memory a, PolyVecK memory v) public view returns (PolyVecK memory r) {\n        // 0..K\n        r.polys[0] = _poly.mpointwise(a, v.polys[0]);\n        r.polys[1] = _poly.mpointwise(a, v.polys[1]);\n        r.polys[2] = _poly.mpointwise(a, v.polys[2]);\n        r.polys[3] = _poly.mpointwise(a, v.polys[3]);\n        return r;\n    }\n\n    function shiftl(PolyVecK memory a) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0] = _poly.shiftl(a.polys[0]);\n        a.polys[1] = _poly.shiftl(a.polys[1]);\n        a.polys[2] = _poly.shiftl(a.polys[2]);\n        a.polys[3] = _poly.shiftl(a.polys[3]);\n        return a;\n    }\n\n    function sub(PolyVecK memory a, PolyVecK memory b) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0] = _poly.sub(a.polys[0], b.polys[0]);\n        a.polys[1] = _poly.sub(a.polys[1], b.polys[1]);\n        a.polys[2] = _poly.sub(a.polys[2], b.polys[2]);\n        a.polys[3] = _poly.sub(a.polys[3], b.polys[3]);\n        return a;\n    }\n\n    function reduce(PolyVecK memory a) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0] = _poly.reduce(a.polys[0]);\n        a.polys[1] = _poly.reduce(a.polys[1]);\n        a.polys[2] = _poly.reduce(a.polys[2]);\n        a.polys[3] = _poly.reduce(a.polys[3]);\n        return a;\n    }\n\n    function caddq(PolyVecK memory a) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0] = _poly.caddq(a.polys[0]);\n        a.polys[1] = _poly.caddq(a.polys[1]);\n        a.polys[2] = _poly.caddq(a.polys[2]);\n        a.polys[3] = _poly.caddq(a.polys[3]);\n        return a;\n    }\n\n    function use_hint(PolyVecK memory a, PolyVecK memory b) public view returns (PolyVecK memory) {\n        // 0..K\n        a.polys[0] = _poly.use_hint(a.polys[0], b.polys[0]);\n        a.polys[1] = _poly.use_hint(a.polys[1], b.polys[1]);\n        a.polys[2] = _poly.use_hint(a.polys[2], b.polys[2]);\n        a.polys[3] = _poly.use_hint(a.polys[3], b.polys[3]);\n        return a;\n    }\n\n    function pack_w1(PolyVecK memory a) public view returns (bytes memory) {\n        bytes memory r = new bytes(K * POLYW1_PACKEDBYTES);\n        for (uint256 i = 0; i < K; ++i) {\n            bytes memory buf = _poly.pack_w1(a.polys[i]);\n            for (uint256 j = 0; j < POLYW1_PACKEDBYTES; ++j) {\n                r[i * POLYW1_PACKEDBYTES + j] = buf[j];\n            }\n        }\n\n        return r;\n    }\n\n    function chknorm(PolyVecL memory v, int32 bound) public view returns (bool) {\n        for (uint256 i = 0; i < L; ++i) {\n            if (_poly.chknorm(v.polys[i], bound)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/Reduce.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"./Constants.sol\";\n\nfunction mreduce64(int64 a) pure returns (int32) {\n    unchecked {\n        int64 t = int64(int32(a) * QINV);\n        t = (a - t * Q) >> 32;\n        return int32(t);\n    }\n}\n\nfunction reduce32(int32 a) pure returns (int32) {\n    unchecked {\n        int32 t = (a + 4194304) >> 23;\n        t = a - t * Q_I32;\n        return t;\n    }\n}\n\nfunction caddq32(int32 a) pure returns (int32) {\n    unchecked {\n        return a + ((a >> 31) & Q_I32);\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/Symmetric.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\n\ncontract Stream {\n    struct State {\n        bytes32 state;\n    }\n\n    function empty() public pure returns (State memory) {}\n\n    function init(uint256 seed, uint16 nonce) public pure returns (State memory) {\n        return State(keccak256(bytes.concat(bytes32(seed), bytes32(uint256(nonce)))));\n    }\n\n    function absorb(State memory st, bytes memory input) public pure returns (State memory) {\n        st.state = keccak256(bytes.concat(st.state, input));\n        return st;\n    }\n\n    function squeeze_bytes(State memory st, uint256 len) public pure returns (State memory, bytes memory) {\n        unchecked {\n            bytes memory buf;\n            while (len > 0) {\n                if (len < 32) {\n                    bytes memory left = new bytes(len);\n                    for (uint256 i = 0; i < len; i++) {\n                        left[i] = st.state[i];\n                    }\n                    buf = bytes.concat(buf, left);\n                    len = 0;\n                } else {\n                    buf = bytes.concat(buf, st.state);\n                    len -= 32;\n                }\n                st.state = keccak256(bytes.concat(st.state));\n            }\n            return (st, buf);\n        }\n    }\n\n    // n block = n * SHAKE128_RATE bytes\n    function s128_squeeze_nblocks(State memory st, uint256 nblocks) public pure returns (State memory, bytes memory) {\n        return squeeze_bytes(st, SHAKE128_RATE * nblocks);\n    }\n\n    // 1 block = SHAKE128_RATE bytes\n    function s128_squeeze_block(State memory st) public pure returns (State memory, bytes memory) {\n        return squeeze_bytes(st, SHAKE128_RATE);\n    }\n\n    // n block = n * SHAKE256_RATE bytes\n    function s256_squeeze_nblocks(State memory st, uint256 nblocks) public pure returns (State memory, bytes memory) {\n        return squeeze_bytes(st, SHAKE256_RATE * nblocks);\n    }\n\n    // 1 block = SHAKE256_RATE bytes\n    function s256_squeeze_block(State memory st) public pure returns (State memory, bytes memory) {\n        return squeeze_bytes(st, SHAKE256_RATE);\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/Sampler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"./Constants.sol\";\n\nfunction rej_uniform(int32[] memory a, uint256 len, bytes memory buf, uint256 buflen)\n    pure\n    returns (int32[] memory, uint256)\n{\n    unchecked {\n        uint256 ctr = 0;\n        uint256 pos = 0;\n        uint32 t = 0;\n\n        while (ctr < len && pos + 3 <= buflen) {\n            t = uint32(uint8(buf[pos]));\n            pos += 1;\n            t |= uint32(uint8(buf[pos])) << 8;\n            pos += 1;\n            t |= uint32(uint8(buf[pos])) << 16;\n            pos += 1;\n            t &= 0x7FFFFF;\n\n            if (t < Q_U32) {\n                a[ctr] = int32(t);\n                ctr += 1;\n            }\n        }\n\n        return (a, ctr);\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/Rounding.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"./Constants.sol\";\n\nfunction use_hint(int32 a, uint8 hint) pure returns (int32) {\n    unchecked {\n        int32 a0 = 0;\n        int32 a1;\n\n        {\n            a1 = (a + 127) >> 7;\n\n            // --\n            // if (GAMMA2 == (Q - 1) / 32) {\n            // a1 = (a1 * 1025 + (1 << 21)) >> 22;\n            // a1 &= 15;\n            // }\n            // else if (GAMMA2 == (Q - 1) / 88)\n            a1 = (a1 * 11275 + (1 << 23)) >> 24;\n            a1 ^= ((43 - a1) >> 31) & a1;\n            // --\n\n            a0 = a - a1 * 2 * GAMMA2_I32;\n            a0 -= (((Q_I32 - 1) / 2 - a0) >> 31) & Q_I32;\n        }\n\n        if (hint == 0) {\n            return a1;\n        }\n\n        // if GAMMA2 == (Q - 1) / 32 {\n        //     if a0 > 0 {\n        //       return (a1 + 1) & 15;\n        //     } else {\n        //       return (a1 - 1) & 15;\n        //     }\n        //   }\n\n        if (a0 > 0) {\n            if (a1 == 43) {\n                return 0;\n            } else {\n                return a1 + 1;\n            }\n        } else {\n            if (a1 == 0) {\n                return 43;\n            } else {\n                return a1 - 1;\n            }\n        }\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/Ntt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"../Reduce.sol\";\n\ncontract Ntt {\n    constructor() {}\n\n    function zetas() public pure returns (int64[N] memory) {\n        return [\n            int64(0),\n            25847,\n            -2608894,\n            -518909,\n            237124,\n            -777960,\n            -876248,\n            466468,\n            1826347,\n            2353451,\n            -359251,\n            -2091905,\n            3119733,\n            -2884855,\n            3111497,\n            2680103,\n            2725464,\n            1024112,\n            -1079900,\n            3585928,\n            -549488,\n            -1119584,\n            2619752,\n            -2108549,\n            -2118186,\n            -3859737,\n            -1399561,\n            -3277672,\n            1757237,\n            -19422,\n            4010497,\n            280005,\n            2706023,\n            95776,\n            3077325,\n            3530437,\n            -1661693,\n            -3592148,\n            -2537516,\n            3915439,\n            -3861115,\n            -3043716,\n            3574422,\n            -2867647,\n            3539968,\n            -300467,\n            2348700,\n            -539299,\n            -1699267,\n            -1643818,\n            3505694,\n            -3821735,\n            3507263,\n            -2140649,\n            -1600420,\n            3699596,\n            811944,\n            531354,\n            954230,\n            3881043,\n            3900724,\n            -2556880,\n            2071892,\n            -2797779,\n            -3930395,\n            -1528703,\n            -3677745,\n            -3041255,\n            -1452451,\n            3475950,\n            2176455,\n            -1585221,\n            -1257611,\n            1939314,\n            -4083598,\n            -1000202,\n            -3190144,\n            -3157330,\n            -3632928,\n            126922,\n            3412210,\n            -983419,\n            2147896,\n            2715295,\n            -2967645,\n            -3693493,\n            -411027,\n            -2477047,\n            -671102,\n            -1228525,\n            -22981,\n            -1308169,\n            -381987,\n            1349076,\n            1852771,\n            -1430430,\n            -3343383,\n            264944,\n            508951,\n            3097992,\n            44288,\n            -1100098,\n            904516,\n            3958618,\n            -3724342,\n            -8578,\n            1653064,\n            -3249728,\n            2389356,\n            -210977,\n            759969,\n            -1316856,\n            189548,\n            -3553272,\n            3159746,\n            -1851402,\n            -2409325,\n            -177440,\n            1315589,\n            1341330,\n            1285669,\n            -1584928,\n            -812732,\n            -1439742,\n            -3019102,\n            -3881060,\n            -3628969,\n            3839961,\n            2091667,\n            3407706,\n            2316500,\n            3817976,\n            -3342478,\n            2244091,\n            -2446433,\n            -3562462,\n            266997,\n            2434439,\n            -1235728,\n            3513181,\n            -3520352,\n            -3759364,\n            -1197226,\n            -3193378,\n            900702,\n            1859098,\n            909542,\n            819034,\n            495491,\n            -1613174,\n            -43260,\n            -522500,\n            -655327,\n            -3122442,\n            2031748,\n            3207046,\n            -3556995,\n            -525098,\n            -768622,\n            -3595838,\n            342297,\n            286988,\n            -2437823,\n            4108315,\n            3437287,\n            -3342277,\n            1735879,\n            203044,\n            2842341,\n            2691481,\n            -2590150,\n            1265009,\n            4055324,\n            1247620,\n            2486353,\n            1595974,\n            -3767016,\n            1250494,\n            2635921,\n            -3548272,\n            -2994039,\n            1869119,\n            1903435,\n            -1050970,\n            -1333058,\n            1237275,\n            -3318210,\n            -1430225,\n            -451100,\n            1312455,\n            3306115,\n            -1962642,\n            -1279661,\n            1917081,\n            -2546312,\n            -1374803,\n            1500165,\n            777191,\n            2235880,\n            3406031,\n            -542412,\n            -2831860,\n            -1671176,\n            -1846953,\n            -2584293,\n            -3724270,\n            594136,\n            -3776993,\n            -2013608,\n            2432395,\n            2454455,\n            -164721,\n            1957272,\n            3369112,\n            185531,\n            -1207385,\n            -3183426,\n            162844,\n            1616392,\n            3014001,\n            810149,\n            1652634,\n            -3694233,\n            -1799107,\n            -3038916,\n            3523897,\n            3866901,\n            269760,\n            2213111,\n            -975884,\n            1717735,\n            472078,\n            -426683,\n            1723600,\n            -1803090,\n            1910376,\n            -1667432,\n            -1104333,\n            -260646,\n            -3833893,\n            -2939036,\n            -2235985,\n            -420899,\n            -2286327,\n            183443,\n            -976891,\n            1612842,\n            -3545687,\n            -554416,\n            3919660,\n            -48306,\n            -1362209,\n            3937738,\n            1400424,\n            -846154,\n            1976782\n        ];\n    }\n\n    function ntt(int32[N] memory a) public pure returns (int32[N] memory) {\n        unchecked {\n            int64[N] memory _zetas = zetas();\n            uint256 j;\n            uint256 k;\n            int32 t;\n            int64 zeta;\n\n            for (uint256 len = 128; len > 0; len >>= 1) {\n                uint256 start = 0;\n                while (start < N) {\n                    k += 1;\n                    zeta = _zetas[k];\n                    j = start;\n                    while (j < start + len) {\n                        t = mreduce64(zeta * int64(a[j + len]));\n                        a[j + len] = a[j] - t;\n                        a[j] += t;\n                        j += 1;\n                    }\n                    start = j + len;\n                }\n            }\n\n            return a;\n        }\n    }\n}\n"
    },
    "lib/dilithium-solidity/src/contract/Invntt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.25;\n\nimport \"../Constants.sol\";\nimport \"../Reduce.sol\";\n\ncontract Invntt {\n    constructor() {}\n\n    function zetas() public pure returns (int64[N] memory) {\n        return [\n            int64(0),\n            25847,\n            -2608894,\n            -518909,\n            237124,\n            -777960,\n            -876248,\n            466468,\n            1826347,\n            2353451,\n            -359251,\n            -2091905,\n            3119733,\n            -2884855,\n            3111497,\n            2680103,\n            2725464,\n            1024112,\n            -1079900,\n            3585928,\n            -549488,\n            -1119584,\n            2619752,\n            -2108549,\n            -2118186,\n            -3859737,\n            -1399561,\n            -3277672,\n            1757237,\n            -19422,\n            4010497,\n            280005,\n            2706023,\n            95776,\n            3077325,\n            3530437,\n            -1661693,\n            -3592148,\n            -2537516,\n            3915439,\n            -3861115,\n            -3043716,\n            3574422,\n            -2867647,\n            3539968,\n            -300467,\n            2348700,\n            -539299,\n            -1699267,\n            -1643818,\n            3505694,\n            -3821735,\n            3507263,\n            -2140649,\n            -1600420,\n            3699596,\n            811944,\n            531354,\n            954230,\n            3881043,\n            3900724,\n            -2556880,\n            2071892,\n            -2797779,\n            -3930395,\n            -1528703,\n            -3677745,\n            -3041255,\n            -1452451,\n            3475950,\n            2176455,\n            -1585221,\n            -1257611,\n            1939314,\n            -4083598,\n            -1000202,\n            -3190144,\n            -3157330,\n            -3632928,\n            126922,\n            3412210,\n            -983419,\n            2147896,\n            2715295,\n            -2967645,\n            -3693493,\n            -411027,\n            -2477047,\n            -671102,\n            -1228525,\n            -22981,\n            -1308169,\n            -381987,\n            1349076,\n            1852771,\n            -1430430,\n            -3343383,\n            264944,\n            508951,\n            3097992,\n            44288,\n            -1100098,\n            904516,\n            3958618,\n            -3724342,\n            -8578,\n            1653064,\n            -3249728,\n            2389356,\n            -210977,\n            759969,\n            -1316856,\n            189548,\n            -3553272,\n            3159746,\n            -1851402,\n            -2409325,\n            -177440,\n            1315589,\n            1341330,\n            1285669,\n            -1584928,\n            -812732,\n            -1439742,\n            -3019102,\n            -3881060,\n            -3628969,\n            3839961,\n            2091667,\n            3407706,\n            2316500,\n            3817976,\n            -3342478,\n            2244091,\n            -2446433,\n            -3562462,\n            266997,\n            2434439,\n            -1235728,\n            3513181,\n            -3520352,\n            -3759364,\n            -1197226,\n            -3193378,\n            900702,\n            1859098,\n            909542,\n            819034,\n            495491,\n            -1613174,\n            -43260,\n            -522500,\n            -655327,\n            -3122442,\n            2031748,\n            3207046,\n            -3556995,\n            -525098,\n            -768622,\n            -3595838,\n            342297,\n            286988,\n            -2437823,\n            4108315,\n            3437287,\n            -3342277,\n            1735879,\n            203044,\n            2842341,\n            2691481,\n            -2590150,\n            1265009,\n            4055324,\n            1247620,\n            2486353,\n            1595974,\n            -3767016,\n            1250494,\n            2635921,\n            -3548272,\n            -2994039,\n            1869119,\n            1903435,\n            -1050970,\n            -1333058,\n            1237275,\n            -3318210,\n            -1430225,\n            -451100,\n            1312455,\n            3306115,\n            -1962642,\n            -1279661,\n            1917081,\n            -2546312,\n            -1374803,\n            1500165,\n            777191,\n            2235880,\n            3406031,\n            -542412,\n            -2831860,\n            -1671176,\n            -1846953,\n            -2584293,\n            -3724270,\n            594136,\n            -3776993,\n            -2013608,\n            2432395,\n            2454455,\n            -164721,\n            1957272,\n            3369112,\n            185531,\n            -1207385,\n            -3183426,\n            162844,\n            1616392,\n            3014001,\n            810149,\n            1652634,\n            -3694233,\n            -1799107,\n            -3038916,\n            3523897,\n            3866901,\n            269760,\n            2213111,\n            -975884,\n            1717735,\n            472078,\n            -426683,\n            1723600,\n            -1803090,\n            1910376,\n            -1667432,\n            -1104333,\n            -260646,\n            -3833893,\n            -2939036,\n            -2235985,\n            -420899,\n            -2286327,\n            183443,\n            -976891,\n            1612842,\n            -3545687,\n            -554416,\n            3919660,\n            -48306,\n            -1362209,\n            3937738,\n            1400424,\n            -846154,\n            1976782\n        ];\n    }\n\n    function invntt(int32[N] memory a) public pure returns (int32[N] memory) {\n        unchecked {\n            int64[N] memory _zetas = zetas();\n            uint256 j;\n            uint256 k = 256;\n            int64 zeta;\n\n            for (uint256 len = 1; len < N; len <<= 1) {\n                uint256 start = 0;\n                while (start < N) {\n                    k -= 1;\n                    zeta = -_zetas[k];\n                    j = start;\n                    while (j < start + len) {\n                        int32 t = a[j];\n                        int32 tl = a[j + len];\n                        a[j] = t + tl;\n                        a[j + len] = mreduce64(int64(t - tl) * zeta);\n                        j += 1;\n                    }\n                    start = j + len;\n                }\n            }\n\n            for (uint256 i = 0; i < N; i++) {\n                a[i] = mreduce64(F * int64(a[i]));\n            }\n\n            return a;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@tetrationlab/lamport/=lib/lamport-solidity/src/",
      "@tetrationlab/dilithium/=lib/dilithium-solidity/src/",
      "@tetrationlab/falcon/=lib/falcon-solidity/src/",
      "dilithium-solidity/=lib/dilithium-solidity/src/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "falcon-solidity/=lib/falcon-solidity/",
      "lamport-solidity/=lib/lamport-solidity/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-upgrades/=lib/openzeppelin-upgrades/",
      "solidity-stringutils/=lib/openzeppelin-upgrades/submodules/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"
    ],
    "optimizer": { "enabled": true, "runs": 200 },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
